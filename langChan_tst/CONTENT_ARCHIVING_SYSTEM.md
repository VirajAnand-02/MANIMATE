# Content Archiving System

## Overview
The video generation pipeline now automatically saves all generated content to a comprehensive archive system. This provides complete traceability, debugging capabilities, and content reuse opportunities.

## Archive Structure

When you run the video generation, a timestamped archive directory is created:
```
archives/
└── {topic}_{timestamp}/
    ├── llm_outputs/
    │   └── script_generation.json          # Initial script LLM output
    ├── audio_files/
    │   ├── scene_1_audio.wav              # Generated TTS audio files
    │   ├── scene_2_audio.wav
    │   └── ...
    ├── scene_codes/
    │   ├── scene_1_code.py                # Raw LLM-generated code
    │   ├── scene_1_final.py               # Final combined template code
    │   ├── scene_2_code.py
    │   ├── scene_2_final.py
    │   └── ...
    ├── layouts/
    │   ├── scene_1_layout.json            # Layout choice and reasoning
    │   ├── scene_2_layout.json
    │   └── ...
    ├── final_videos/
    │   ├── scene_1_final.mp4              # Individual scene videos
    │   ├── scene_2_final.mp4
    │   └── ...
    ├── {topic}_final.mp4                  # Complete concatenated video
    └── generation_summary.json            # Complete pipeline statistics
```

## Content Details

### LLM Outputs (`llm_outputs/`)
- **script_generation.json**: Complete JSON output from the script generation LLM
  - Contains scene breakdown, narration text, animation descriptions
  - Preserves original LLM reasoning and structure

### Audio Files (`audio_files/`)
- **scene_X_audio.wav**: Generated TTS audio for each scene
  - Preserved in original quality (24kHz, 16-bit)
  - Includes both batch and individual TTS results
  - Can be reused for regenerating videos with different visuals

### Scene Codes (`scene_codes/`)
- **scene_X_code.py**: Raw code generated by Manim LLM
  - Includes metadata comments (generation method, thinking usage, timestamp)
  - Preserves original LLM output before template combination
- **scene_X_final.py**: Complete runnable Manim code
  - Combined with layout templates
  - Includes narration text and audio duration
  - Ready for independent rendering
- **scene_X_fallback.py**: Fallback template code (if LLM failed)

### Layouts (`layouts/`)
- **scene_X_layout.json**: Layout decision and context
  - Layout choice (title_and_main_content, split_screen, custom)
  - Original scene data that influenced the decision
  - Timestamp for debugging layout algorithm changes

### Final Videos (`final_videos/`)
- **scene_X_final.mp4**: Individual scene videos with audio
  - High quality (720p@60fps)
  - Audio-synchronized with proper padding
  - Can be used for scene-level editing or reordering

### Summary (`generation_summary.json`)
- Complete pipeline statistics and metadata
- Success/failure rates for each processing stage
- Timing information and performance metrics
- Error details for debugging

## Benefits

### 🔍 **Debugging and Troubleshooting**
- **Complete Audit Trail**: Every step is preserved for analysis
- **Error Isolation**: Identify exactly which stage failed and why
- **Performance Analysis**: Compare generation times and success rates
- **Content Quality**: Review LLM outputs to improve prompts

### 🔄 **Content Reuse**
- **Audio Reuse**: Use existing audio with different visuals
- **Code Templates**: Extract successful scene patterns for reuse
- **Scene Remixing**: Combine scenes from different generations
- **A/B Testing**: Compare different approaches for same content

### 📊 **Analytics and Optimization**
- **Success Rate Tracking**: Monitor LLM and TTS performance over time
- **Content Patterns**: Analyze which layouts work best for different topics
- **Resource Usage**: Track generation costs and timing
- **Quality Metrics**: Correlate inputs with successful outputs

### 🛠️ **Development and Maintenance**
- **Regression Testing**: Verify changes don't break existing functionality
- **Prompt Engineering**: Iteratively improve LLM prompts based on archived outputs
- **Algorithm Tuning**: Optimize layout selection and template systems
- **User Feedback**: Correlate user preferences with generated content

## Usage Examples

### Reusing Audio with Different Visuals
```bash
# Generate new video with existing audio
cp archives/math_topic_20250823-143022/audio_files/scene_1_audio.wav ./reuse/
# Modify scene code and regenerate with same audio
```

### Analyzing Generation Patterns
```bash
# Find all successful custom layouts
find archives -name "*layout.json" -exec grep -l '"custom"' {} \;

# Compare success rates across different generations
jq '.manim_stats.success' archives/*/generation_summary.json
```

### Scene-Level Editing
```bash
# Extract specific scenes for custom video assembly
cp archives/topic1_*/final_videos/scene_2_final.mp4 ./custom_video/
cp archives/topic2_*/final_videos/scene_1_final.mp4 ./custom_video/
# Concatenate in custom order
```

### Debug Failed Generations
```bash
# Check what went wrong in a specific generation
cat archives/failed_topic_*/generation_summary.json | jq '.scenes[].render'
# Review the generated code that failed
cat archives/failed_topic_*/scene_codes/scene_3_code.py
```

## Storage Considerations

### Disk Usage
- **Audio Files**: ~500KB-2MB per scene (varies with narration length)
- **Video Files**: ~5-20MB per scene (720p@60fps, varies with duration)
- **Code Files**: ~5-50KB per scene
- **JSON Files**: ~1-10KB per file
- **Total per Video**: ~50-200MB for typical 3-5 scene video

### Cleanup Recommendations
```bash
# Clean archives older than 30 days
find archives -type d -mtime +30 -exec rm -rf {} \;

# Keep only successful generations
find archives -name "generation_summary.json" -exec jq -r '. | select(.output_file == null) | input_filename' {} \; | xargs dirname | xargs rm -rf

# Archive audio files separately for long-term storage
rsync -av archives/*/audio_files/ audio_library/
```

## Configuration

### Environment Variables
- **ARCHIVE_ENABLED**: Set to "false" to disable archiving (default: "true")
- **ARCHIVE_PATH**: Custom archive location (default: "./archives")
- **ARCHIVE_AUDIO**: Save audio files (default: "true")
- **ARCHIVE_VIDEOS**: Save individual scene videos (default: "true")

### Selective Archiving
```python
# In gem_mnm.py, you can configure what to archive:
ARCHIVE_CONFIG = {
    "llm_outputs": True,
    "audio_files": True,
    "scene_codes": True,
    "layouts": True,
    "final_videos": True,
    "summary": True
}
```

## Future Enhancements

### Planned Features
1. **Archive Compression**: Automatic compression of older archives
2. **Content Indexing**: Searchable database of generated content
3. **Version Control**: Git-like versioning for iterative improvements
4. **Cloud Sync**: Optional backup to cloud storage
5. **Analytics Dashboard**: Web interface for archive analysis
6. **Content Recommendation**: Suggest reusable components based on topic similarity

### Integration Opportunities
1. **Video Editing**: Import archives into editing software
2. **Content Management**: CMS integration for educational platforms
3. **Quality Assurance**: Automated quality scoring of generated content
4. **Workflow Automation**: Trigger post-processing based on archive contents

---

**Implementation Date**: August 23, 2025
**Archive Format Version**: 1.0
**Compatibility**: All generated content is forward-compatible
